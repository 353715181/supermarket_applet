"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBRef = exports.isDBRefLike = void 0;
const utils_1 = require("./parser/utils");
/** @internal */
function isDBRefLike(value) {
    return utils_1.isObjectLike(value) && value['$id'] != null && value['$ref'] != null;
}
exports.isDBRefLike = isDBRefLike;
/**
 * A class representation of the BSON DBRef type.
 * @public
 */
class DBRef {
    /**
     * @param collection - the collection name.
     * @param oid - the reference ObjectId.
     * @param db - optional db name, if omitted the reference is local to the current db.
     */
    constructor(collection, oid, db, fields) {
        // check if namespace has been provided
        const parts = collection.split('.');
        if (parts.length === 2) {
            db = parts.shift();
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            collection = parts.shift();
        }
        this.collection = collection;
        this.oid = oid;
        this.db = db;
        this.fields = fields || {};
    }
    // Property provided for compatibility with the 1.x parser
    // the 1.x parser used a "namespace" property, while 4.x uses "collection"
    /** @internal */
    get namespace() {
        return this.collection;
    }
    set namespace(value) {
        this.collection = value;
    }
    /** @internal */
    toJSON() {
        const o = Object.assign({
            $ref: this.collection,
            $id: this.oid
        }, this.fields);
        if (this.db != null)
            o.$db = this.db;
        return o;
    }
    /** @internal */
    toExtendedJSON(options) {
        options = options || {};
        let o = {
            $ref: this.collection,
            $id: this.oid
        };
        if (options.legacy) {
            return o;
        }
        if (this.db)
            o.$db = this.db;
        o = Object.assign(o, this.fields);
        return o;
    }
    /** @internal */
    static fromExtendedJSON(doc) {
        const copy = Object.assign({}, doc);
        delete copy.$ref;
        delete copy.$id;
        delete copy.$db;
        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
    }
    /** @internal */
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return this.inspect();
    }
    inspect() {
        // NOTE: if OID is an ObjectId class it will just print the oid string.
        const oid = this.oid === undefined || this.oid.toString === undefined ? this.oid : this.oid.toString();
        return `DBRef("${this.namespace}", "${oid}"${this.db ? `, "${this.db}"` : ''})`;
    }
}
exports.DBRef = DBRef;
Object.defineProperty(DBRef.prototype, '_bsontype', { value: 'DBRef' });
//# sourceMappingURL=db_ref.js.map